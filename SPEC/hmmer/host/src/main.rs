// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{HMMER_ELF, HMMER_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::time::Instant;

// Amino acid alphabet
const AMINO_ACIDS: &[u8] = b"ACDEFGHIKLMNPQRSTVWY";
const AA_COUNT: usize = 20;

// Protein sequence structure for serialization
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Sequence {
    name: String,
    data: Vec<u8>,
}

// HMMER input parameters
#[derive(Debug, Serialize, Deserialize)]
struct HmmerInput {
    sequences: Vec<Sequence>,
    hmm_length: usize,
    input_size: usize,
}

// HMMER results from guest
#[derive(Debug, Serialize, Deserialize)]
struct HmmerOutput {
    results: Vec<SearchResult>,
    total_sequences: usize,
    processing_time_ms: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct SearchResult {
    sequence_name: String,
    score: f64,
    e_value: f64,
    alignment_start: usize,
    alignment_end: usize,
}

fn read_sequences(filename: &str, max_sequences: usize) -> Vec<Sequence> {
    let mut sequences = Vec::new();

    match File::open(filename) {
        Ok(file) => {
            let reader = BufReader::new(file);
            let mut current_name = String::new();
            let mut current_data = Vec::new();

            for line in reader.lines() {
                if let Ok(line) = line {
                    let line = line.trim();
                    if line.starts_with('>') {
                        if !current_name.is_empty() && !current_data.is_empty() {
                            sequences.push(Sequence {
                                name: current_name.clone(),
                                data: current_data.clone(),
                            });
                            if sequences.len() >= max_sequences {
                                break;
                            }
                        }
                        current_name = line[1..].to_string();
                        current_data.clear();
                    } else {
                        current_data.extend(line.bytes());
                    }
                }
            }

            // Add last sequence
            if !current_name.is_empty()
                && !current_data.is_empty()
                && sequences.len() < max_sequences
            {
                sequences.push(Sequence {
                    name: current_name,
                    data: current_data,
                });
            }
        }
        Err(_) => {
            // Generate synthetic sequences if file doesn't exist
            println!(
                "Generating {} synthetic protein sequences...",
                max_sequences
            );
            for i in 0..max_sequences {
                let seq_len = 50 + (i % 200); // Variable length sequences
                let mut seq_data = Vec::with_capacity(seq_len);

                for j in 0..seq_len {
                    let aa_idx = (i * 17 + j * 31) % AA_COUNT;
                    seq_data.push(AMINO_ACIDS[aa_idx]);
                }

                sequences.push(Sequence {
                    name: format!("synthetic_seq_{}", i),
                    data: seq_data,
                });
            }
        }
    }

    sequences
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args: Vec<String> = env::args().collect();

    // Parse command line arguments
    let input_size = if args.len() > 1 {
        args[1].parse::<usize>().unwrap_or(100)
    } else {
        100 // Smaller default for zkVM due to constraints
    };

    let hmm_length = if args.len() > 2 {
        args[2].parse::<usize>().unwrap_or(25)
    } else {
        25 // Smaller default for zkVM
    };

    let sequence_file = if args.len() > 3 {
        &args[3]
    } else {
        "sequences.fasta"
    };

    println!("RISC Zero HMMER Protein Sequence Search");
    println!("Input size: {} sequences", input_size);
    println!("HMM length: {} states", hmm_length);
    println!("Sequence file: {}", sequence_file);
    println!();

    // Read sequences on the host
    let start_time = Instant::now();
    let sequences = read_sequences(sequence_file, input_size);
    println!(
        "Read {} sequences in {:?}",
        sequences.len(),
        start_time.elapsed()
    );

    // Create input for the guest
    let hmmer_input = HmmerInput {
        sequences: sequences.clone(),
        hmm_length,
        input_size: sequences.len(),
    };

    // Calculate estimated computation size
    let total_residues: usize = sequences.iter().map(|s| s.data.len()).sum();
    println!("Total residues to process: {}", total_residues);
    println!("Estimated computation: {} alignments", sequences.len());
    println!();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    println!("Setting up zkVM environment...");
    let env = ExecutorEnv::builder()
        .write(&hmmer_input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    println!("Starting zkVM proof generation...");
    let prove_start = Instant::now();

    let prove_info = prover.prove(env, HMMER_ELF).unwrap();
    let prove_time = prove_start.elapsed();

    println!("Proof generation completed in {:?}", prove_time);
    println!("Proof cycles: {}", prove_info.stats.total_cycles);
    println!("Proof segments: {}", prove_info.stats.segments);

    // extract the receipt.
    let receipt = prove_info.receipt;

    // Retrieve the HMMER results from the receipt journal
    let hmmer_output: HmmerOutput = receipt.journal.decode().unwrap();

    println!("\n=== HMMER Results from zkVM ===");
    println!("Sequences processed: {}", hmmer_output.total_sequences);
    println!(
        "Guest processing time: {} ms",
        hmmer_output.processing_time_ms
    );

    // Calculate performance metrics
    let throughput = total_residues as f64 / (hmmer_output.processing_time_ms as f64 / 1000.0);
    println!("Throughput: {:.0} residues/second (guest)", throughput);

    let proof_throughput = total_residues as f64 / prove_time.as_secs_f64();
    println!(
        "Overall throughput: {:.0} residues/second (including proof)",
        proof_throughput
    );

    // Display top results
    println!("\nTop 10 results:");
    println!(
        "{:<20} {:<12} {:<12} {:<10} {:<10}",
        "Sequence", "Score", "E-value", "Start", "End"
    );
    println!("{}", "-".repeat(70));

    for result in hmmer_output.results.iter().take(10) {
        println!(
            "{:<20} {:<12.2} {:<12.2e} {:<10} {:<10}",
            if result.sequence_name.len() > 20 {
                result.sequence_name[..17].to_string() + "..."
            } else {
                result.sequence_name.clone()
            },
            result.score,
            result.e_value,
            result.alignment_start,
            result.alignment_end
        );
    }

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("\nVerifying receipt...");
    receipt.verify(HMMER_ID).unwrap();
    println!("Receipt verified successfully!");

    // Performance summary
    println!("\n=== Performance Summary ===");
    println!("Host sequence loading: {:?}", start_time.elapsed());
    println!("zkVM proof generation: {:?}", prove_time);
    println!("Guest computation: {} ms", hmmer_output.processing_time_ms);
    println!(
        "Proof overhead: {:.1}x",
        prove_time.as_millis() as f64 / hmmer_output.processing_time_ms as f64
    );
    println!("Total cycles: {}", prove_info.stats.total_cycles);
    println!(
        "Cycles per sequence: {}",
        prove_info.stats.total_cycles / sequences.len() as u64
    );
    println!(
        "Cycles per residue: {}",
        prove_info.stats.total_cycles / total_residues as u64
    );
}
